Функция strlcpy - нестандартная функция для копирования строки ограниченного размера. Замена стандартной функции strcpy.

#include <string.h>

size_t	strlcpy(char *dst, const char *src, size_t size);

dst - указатель на буфер назначения
src - указатель на исходную строку
size - размер буфера назначения

Функция strlcpy копирует из строки src в буфер dst не более чем size-1 символов и гарантированно устанавливает в конце строки нулевой символ.

Возвращаемое значение:
Размер строки по адресу src. Возвращаемое значение не зависит от того, удалось ли скопировать строку полностью или нет. 
Это позволяет легко определить что буфер назначения слишком мал для копируемой строки.

=====================================================
Описание из мануала переведенное мной:

Функции strlcpy() и strlcat() копируют и объединяют строки соответственно.
В отличие от strncpy() и strncat(), они принимают полный размер буфера(не просто длину) и гарантируют что результат будет являться нуль-терминированной строкой(до тех пор пока size > 0 или, в случае strlcat(), до тех пор, пока существует по крайней мере, один байт свободный in dst). Обратите внимание что байт завершения конца строки должен быть включен в size.
Так же обратите внимание что для strlcpy() и strlcat() исходная строка src должна быть нуль-терминированной и для strlcat() оба параметра src и dst должны быть нуль-терминированы.

Функция strlcpy() копирует до size-1 символов из нуль-терминированной строки src в строку dst, нуль-терминирует строку dst.

Функция strlcat() добавляет нуль-терминированную строку src в конец строки dst. Будет добавлено не более size-strlen(dst)-1 байт с нуль-терминирование строки.

Возвращаемые значения:
Функции strlcpy() и strlcat() возвращают общую длину строки, которую они пытались скопировать\объединить. 

Для strcpy() это означает возврат длины src.
Для strlcat() это означает начальную длину dst + длину src.

Обратите внимание, однако, что если strlcat() пересекает строку (пока оставляю непереведенный кусок, т.к. не могу его адекватно перевести)

     Note, however, that if strlcat() traverses size characters without finding a NUL, the length of the string is considered to be size and the destination string will not be NUL-terminated (since there was no space for the NUL).          This keeps strlcat() from running off the end of a string.  In practice this should not happen (as it means that either size is incorrect or that dst is not a proper “C” string).  The check exists to prevent potential security problems in incorrect code.
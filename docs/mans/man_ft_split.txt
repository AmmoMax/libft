char	**ft_split(char const *s, char c);

Параметры:
s - строка для разбиения
c - символ разделитель

Возвращаемое значение:
Массив указателей на строки - результат разбиения. NULL - если выделение памяти прошло с ошибкой.

Описание:
Выделяет память и возвращает массив строк, полученных разбиением исходной строки s с символом c в качестве разделителя.Массив должен заканчиваться нулевым указателем.

Примерный алгоритм работы:
0. Выделяем память под результирующий массив указателей, с помощью заранее написанной функции ft_word_count(). Котролируем выделение памяти.

1. Итерируемся по основной строке, количество итераций будет зависеть от количества слов в строке.

	Счетчики:
		1. Счетчик общей итерации циклов, сравнивается с количеством слов в исходной строке.
		2. Счетчик движения по исходной строке внутри цикла.
		3. Счетчик движения по результирующему массиву указателей.

	1.1. Передаем в функцию определения длины слова текущую позицию в основной строке. Получаем от нее длину.
	1.2. Используя длину слова - выделяем память. Контролируем выделение памяти.
	1.3. В цикле итерируемся по основной строке до следующего слова и записываем его в результирующий массив указателей.
	1.4 Записываем в конец \0.
2. Записываем в конец результирующего массива указателей NULL.
=============================
Еще вариант:
=============================
Работу выполняем в два прохода по исходной строке:
1. Считаем количество слов - рассчитываем длину результирующего массива указателей.
	1.1 Написать фукнцию подсчета количества слов в строке.

2. Зная количество слов - выделяем память под результирующий массив указателей + 1 символ для NULL - обозначения конца массива.

3. В цикле итерируемся по исходной строке,выделяем слова, выделяем память под них и записываем указатель на текущее  слово в результирующий массив указателей.
	3.1 Функция измерения длины слова. Передаем в нее строку и символ - она возвращает длину первого слова. Соответственно в главной фунции мы будем смещаться по основной строке и передавать каждый раз строку меньше.
=============================

1. Движемся до конца строки, пока не встретим символ \0, получаем текущий символ и проверяем его.
	1. Если текущий символ - разделитель.
		Мы вышли за слово, устанавливаем признак ВНЕ слова.
		Перемещаемся к следующему символу.
	2. Если признак - ВНЕ слова.
		Первое условие не выполнилось, значит проверяемый символ не разделитель, значит мы находимся в слове.
		Устанавливаем признак ВНУТРИ слова.
		Увеличиваем счетчик слов на 1.
		Перемещаемс к следующему символу.
	3. В любых других случаях
		Перемещаемся к следующему символу.
2. Доходим до конца строки и цикл завершается.
Возвращаем количество слов в строке.
=============================
Что требуется:
1. Признак подстроки.
2. Счетчик слов.
=============================


Функция memmove копирует n символов из объекта в памяти, на который указывает s2 в объект, на который указывает s1.
Копирование происходит так, как если бы символы из объекта, указываемого на s2, сначала копировались во временный массив символов, 
который не перекрывает объекты, указываемые на s1 и s2, а затем символы из временного массива копировались в объект, указываемый на s1.

Возвращает указатель на s1

#include <string.h>
void	*memmove(void *s1, const void *s2, size_t n);

Значения аргументов:
s1 - указатель на память, В которую надо скопировать данные
s2 - указатель на памяти ИЗ которой надо скопировать данные
n - количество символов в байтах, которые надо скопировать



Вопросы по написанию кастомной реализации:
1. Можно ли и надо ли использовать malloc? (нет)


Проблемы и недостатки функции memmove и memset:
1. Обе фукнции не проверяют оканчивается ли строка завершающим нулевым символом. Их надо аккуратно использовать со строками.
2. Поведение обеих функций будет неопределенным если попытаться получить доступ к данным за длиной буферов source и destination.
3. Обе функции не проверяют валидность буфера назначения.

